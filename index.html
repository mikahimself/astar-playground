<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css"/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;1,400&display=swap" rel="stylesheet">
    <title>Tbonk otabix</title>
</head>
<body>
    <div class="container">
        <div class="desc-container">
            <div class="desc-title">A Star - Coding Train version</div>
            <div class="desc-content">A Star implementation modeled after the solution presented in Coding Train's <a href="https://www.youtube.com/watch?v=aKYlikFAV4k">A Star Coding Challenge</a>.
            <div class="option-container">
                <div class="option-title">
                    Heuristic type
                </div>
                <form class="option-form">
                    <div class="option-content">
                        <input type="radio" id="heuristic-euclidean" name="heuristic-type" value="euclidean" checked>
                        <label for="heuristic-euclidean">Euclidean</label>
                    </div>
                    <div class="option-content">
                        <input type="radio" id="heuristic-manhattan" name="heuristic-type" value="manhattan">
                        <label for="heuristic-manhattan">Manhattan</label>
                    </div>
                </form>
            </div>
            
            </div>
            <div class="canvas-container">
                <canvas id="myCanvas" class="canvas" width="401" height="401" />
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>
    <script src="Cell.js"></script>
    <script src="AStar.js"></script>
    <script>
        var socket = io("http://localhost:3000");
        var mapData;
        var baseMap;
        var openSet = []; // items yet to be evaluated
        var closedSet = []; // evaluated items
        var start;
        var end;
        var width;
        var height;
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        ctx.lineWidth = 1;
        canvas.addEventListener("click", getCanvasClick);
        var drawnClosed = [];
        var drawnOpen = [];
        var heuristicType = "euclidean";
        var loopSet = false;
        var assStar = new AStar(heuristicType);

        setupPage()
        getData();

        function setupPage() {
            document.querySelectorAll("input[name='heuristic-type']").forEach((input) => {
                input.addEventListener("change", setHeuristicType);
            })
        }

        function setHeuristicType(e) {
            heuristicType = e.target.value;
            assStar.setHeuristicType(heuristicType);

            //resetValues();
            //astar();
        }

        async function getData() {
            const mapData = await fetch("http://localhost:3000/api/map", {
                method: "GET"
            })
            .then(res => res.json());
            setupMap(mapData.map)
        }

        async function setupMap(data) {
            baseMap = data;
            mapData = new Array(data.length);
            height = 400 / baseMap.length;
            width = 400 / baseMap[0].length;

            for (let y = 0; y < data.length; y++) {
                 mapData[y] = new Array(data[y].length)
            }
            for (let y = 0; y < data.length; y++) {
                 for (let x = 0; x < data[y].length; x++) {
                     mapData[y][x] = new Cell(x, y, width, height);
                 }
            }
            // Map neighbors
            mapData.map(subMap => subMap.map(item => item.getNeighbors(mapData)));

            start = mapData[0][0];
            openSet.push(start);
            endY = mapData.length - 1;
            endX = mapData[mapData.length - 1].length - 1;
            end = mapData[38][37];
            drawMap(data)
            openSet.map(item => item.show(ctx, "#000", "#0f0"));
            
            //astar();

        }

        function getHeuristic(a, b) {
            if (heuristicType == "euclidean") {
                return Math.sqrt(((b.x - a.x) * (b.x - a.x)) + ((b.y - a.y) * (b.y - a.y))); // Euclidean distance
            } else {
                return Math.abs(b.x - a.x) + Math.abs(b.y - a.y); // Manhattan distance
            }
        }

        function resetValues() {
            drawnClosed = [];
            drawnOpen = [];
            closedSet = [];
            openSet = [];
            openSet.push(start);
            drawMap(baseMap);
            loopSet = true;
        }

        function getCanvasClick(e) {
            drawMap(baseMap);

            var gridX = Math.floor(e.offsetX / width);
            var gridY = Math.floor(e.offsetY / height);
            // resetValues();
            end = mapData[gridY][gridX];
            start = mapData[0][0];
            var path = assStar.findRoute(start, end);
            drawSetSquares(path[1], path[2]);
            // console.log()
            for (let cell of path[0]) {
                cell.show(ctx, "#000", "#FFC107")
            }
        }

        function findPath(pointFrom) {
            path = [];
            path.push(pointFrom)
            var temp = pointFrom;
            while (temp.previous) {
                path.push(temp.previous);
                temp = temp.previous;
            }
            return path;
        }

        function astar() {
            counter = 0;
            
            // Loop while there are items to investigate
            while (openSet.length > 0 && loopSet) {
                // Find the item with the lowest f
                var indexOfLowestF = 0;

                openSet.map((item, index) => {
                    if (item.f < openSet[indexOfLowestF].f) {
                        indexOfLowestF = index;
                    }
                });

                // Set the Cell with the lowest f as the current item
                let current = openSet[indexOfLowestF];
                // Then move it from the openSet to the closedSet
                openSet = openSet.filter((item, index) => !(item.equals(current)));
                closedSet.push(current);

                // If the item with the lowest f is the goal, we're done.
                if (current.equals(end)) {
                    loopSet = false;
                    var path = findPath(current);
                    loopSet = false;
                    drawSetSquares();
                    for (let cell of path) {
                        cell.show(ctx, "#000", "#FFC107")
                    }
                    break;
                };


                // check the current item's neighbors
                for (let neighbor of current.neighbors) {
                    // process only items that have not been processed
                    if (!closedSet.includes(neighbor)) {
                        // assign temporary g score. Since this is a neighbor, 
                        // it's cost is the current item's g score, plus 1.
                        var tempG = current.g + 1;
                        // Check if we've already been here with a lower g.
                        // If not, update g score
                        if (openSet.includes(neighbor)) {
                            if  (tempG < neighbor.g) {
                                neighbor.g = tempG;
                            }
                        // otherwise, add g score and add neighbor to open set.
                        } else {
                            neighbor.g = tempG;
                            // Here, calculate the heuristic, that is, an educated
                            // guess about the distance to the end from the neighbor.
                            // Currently just the euclidean distance
                            neighbor.h = getHeuristic(neighbor, end);
                            neighbor.f = neighbor.g + neighbor.h;
                            // Keep track of the cell that we came from
                            neighbor.previous = current;
                            openSet.push(neighbor)
                        }
                    }
                }
            }
        }

        function drawSetSquares(openSet, closedSet) {
            let newToDraw = closedSet.filter(item => !drawnClosed.includes(item));
            drawnClosed.push(...newToDraw);
            let newOpenToDraw = openSet.filter(item => !drawnOpen.includes(item) && !drawnClosed.includes(item));
            drawnOpen.push(...newOpenToDraw)
            //newToDraw.map(item => item.show(ctx, "#000", "#D81B60"))
            closedSet.map(item => item.show(ctx, "#000", "#D81B60"))
            //newOpenToDraw.map(item => item.show(ctx, "#000", "#1E88E5"));
            openSet.map(item => item.show(ctx, "#000", "#1E88E5"));
        }

        function drawMap(map) {
            ctx.fillStyle = "#fff";
            ctx.fillRect(0,0, 400, 400);
            ctx.strokeStyle = "#111";
            ctx.globalAlpha = 1;


            for (let y = 0; y <= map.length; y++) {
                ctx.beginPath();
                ctx.moveTo(0.5, y * height + 0.5);
                ctx.lineTo(400.5, y * height + 0.5);
                ctx.moveTo(y * width + 0.5, 0.5);
                ctx.lineTo(y * width + 0.5, 400.5);
                ctx.stroke();
            }
        }
        //getData()

        function drawTile(ctx, posX, posY, width, height, borderWidth, borderColor, fillColor) {
            ctx.fillStyle = fillColor;
            ctx.fillRect(posX, posY, width, height);
            ctx.strokeStyle = borderColor
            ctx.rect(posX, posY, width, height);
            ctx.stroke();
        }
    </script>
</body>
</html>